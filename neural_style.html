<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Neural Transfer Using PyTorch &#8212; Data-Science NA documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/copybutton.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="first order and second order ordinary differential equations (ODE)s" href="1st_2nd_order_ODE.html" />
    <link rel="prev" title="Using a toy dataset to better understand SHapley Additive exPlanations (SHAP)" href="understanding_SHAP.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          Data-Science</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption" role="heading"><span class="caption-text">Linear Analysis Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Bootstrapped_t_test_example.html">Create a bootstrapped t_test function and show it off using the iris data set</a></li>
<li class="toctree-l1"><a class="reference internal" href="groupby_apply_ML.html">An example of a use of groupby apply to apply a model to a set of individual groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="Random_walk_on_pink_background.html">Random Walk</a></li>
<li class="toctree-l1"><a class="reference internal" href="uninformative_feature_effect_on_R2.html">Looking at how adding an extra feature with varying levels of relevance effects the r2_score</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Machine Learning Notebooks</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="gower_clustering.html">Gower clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="gower_clustering.html#Multiclass-example-1.">Multiclass example 1.</a></li>
<li class="toctree-l1"><a class="reference internal" href="gower_clustering.html#Multiclass-example-2.">Multiclass example 2.</a></li>
<li class="toctree-l1"><a class="reference internal" href="gower_clustering.html#Binary-example">Binary example</a></li>
<li class="toctree-l1"><a class="reference internal" href="ML-workflow.html">Machine Learning Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="stress_prediction.html">Stress prediction based on biometrics data</a></li>
<li class="toctree-l1"><a class="reference internal" href="stress_prediction.html#Read-in-data">Read in data</a></li>
<li class="toctree-l1"><a class="reference internal" href="stress_prediction.html#Exploratory-Data-Analysis-(EDA)">Exploratory Data Analysis (EDA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="synthetic_ordinal_data.html">Creating synthetic ordinal data</a></li>
<li class="toctree-l1"><a class="reference internal" href="synthetic_ordinal_data.html#Shuffle-the-target-so-there-are-no-variables-which-have-a-perfect-classification">Shuffle the target so there are no variables which have a perfect classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="understanding_SHAP.html">Using a toy dataset to better understand SHapley Additive exPlanations (SHAP)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Neural Transfer Using PyTorch</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">NLTSA Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="1st_2nd_order_ODE.html">first order and second order ordinary differential equations (ODE)s</a></li>
<li class="toctree-l1"><a class="reference internal" href="1st_2nd_order_ODE.html#1st-order-ODE">1st order ODE</a></li>
<li class="toctree-l1"><a class="reference internal" href="1st_2nd_order_ODE.html#2nd-order-ODE">2nd order ODE</a></li>
<li class="toctree-l1"><a class="reference internal" href="facs_test_CRDs.html">Methodology</a></li>
<li class="toctree-l1"><a class="reference internal" href="facs_test_CRDs.html#Plot-all-of-the-time-series-levels-of-the-FACS">Plot all of the time series levels of the FACS</a></li>
<li class="toctree-l1"><a class="reference internal" href="fatigue_change_over_time.html">Methodology</a></li>
<li class="toctree-l1"><a class="reference internal" href="scikit-identification-example.html">scikit-identification Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="seizure_patterns.html">Looking for patterns in grand mal seizures</a></li>
<li class="toctree-l1"><a class="reference internal" href="seizure_patterns.html#Context">Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="seizure_patterns.html#About-Tubular-Sclerosis">About Tubular Sclerosis</a></li>
<li class="toctree-l1"><a class="reference internal" href="smoothing_options.html">Testing out rolling smoothing functions</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Neural Transfer Using PyTorch</a><ul>
<li><a class="reference internal" href="#Introduction">Introduction</a></li>
<li><a class="reference internal" href="#Underlying-Principle">Underlying Principle</a></li>
<li><a class="reference internal" href="#Importing-Packages-and-Selecting-a-Device">Importing Packages and Selecting a Device</a></li>
<li><a class="reference internal" href="#Loading-the-Images">Loading the Images</a></li>
<li><a class="reference internal" href="#Loss-Functions">Loss Functions</a></li>
<li><a class="reference internal" href="#Importing-the-Model">Importing the Model</a></li>
<li><a class="reference internal" href="#Gradient-Descent">Gradient Descent</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars and line breaks on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
    white-space: pre;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
</style>
<section id="Neural-Transfer-Using-PyTorch">
<h1>Neural Transfer Using PyTorch<a class="headerlink" href="#Neural-Transfer-Using-PyTorch" title="Permalink to this heading">¶</a></h1>
<section id="Introduction">
<h2>Introduction<a class="headerlink" href="#Introduction" title="Permalink to this heading">¶</a></h2>
<p>This notebook is based on the following tutorial: <a class="reference external" href="https://pytorch.org/tutorials/advanced/neural_style_tutorial.html">https://pytorch.org/tutorials/advanced/neural_style_tutorial.html</a></p>
<p>Neural-Style, or Neural-Transfer, allows you to take an image and reproduce it with a new artistic style. The algorithm takes three images, an input image, a content-image, and a style-image, and changes the input to resemble the content of the content-image and the artistic style of the style-image.</p>
</section>
<section id="Underlying-Principle">
<h2>Underlying Principle<a class="headerlink" href="#Underlying-Principle" title="Permalink to this heading">¶</a></h2>
<p>The principle is simple: we define two distances, one for the content (<span class="math notranslate nohighlight">\(D_C\)</span>) and one for the style (<span class="math notranslate nohighlight">\(D_S\)</span>). <span class="math notranslate nohighlight">\(D_C\)</span> measures how different the content is between two images while <span class="math notranslate nohighlight">\(D_S\)</span> measures how different the style is between two images. Then, we take a third image, the input, and transform it to minimize both its content-distance with the content-image and its style-distance with the style-image. Now we can import the necessary packages and begin the neural transfer.</p>
</section>
<section id="Importing-Packages-and-Selecting-a-Device">
<h2>Importing Packages and Selecting a Device<a class="headerlink" href="#Importing-Packages-and-Selecting-a-Device" title="Permalink to this heading">¶</a></h2>
<p>Below is a list of the packages needed to implement the neural transfer.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">torch</span></code>, <code class="docutils literal notranslate"><span class="pre">torch.nn</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy</span></code> (indispensables packages for neural networks with PyTorch)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">torch.optim</span></code> (efficient gradient descents)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PIL</span></code>, <code class="docutils literal notranslate"><span class="pre">PIL.Image</span></code>, <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> (load and display images)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">torchvision.transforms</span></code> (transform PIL images into tensors)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">torchvision.models</span></code> (train or load pre-trained models)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">copy</span></code> (to deep copy the models; system package)</p></li>
<li><p>see the <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> file in this folder</p></li>
</ul>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from __future__ import print_function

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

from PIL import Image
import matplotlib.pyplot as plt

import torchvision.transforms as transforms
import torchvision.models as models
import torchvision.transforms.functional as fn

import copy
</pre></div>
</div>
</div>
<p>Next, we need to choose which device to run the network on and import the content and style images. Running the neural transfer algorithm on large images takes longer and will go much faster when running on a GPU. We can use <code class="docutils literal notranslate"><span class="pre">torch.cuda.is_available()</span></code> to detect if there is a GPU available. Next, we set the <code class="docutils literal notranslate"><span class="pre">torch.device</span></code> for use throughout the tutorial. Also the <code class="docutils literal notranslate"><span class="pre">.to(device)</span></code> method is used to move tensors or modules to a desired device.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)
device
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
device(type=&#39;cpu&#39;)
</pre></div></div>
</div>
</section>
<section id="Loading-the-Images">
<h2>Loading the Images<a class="headerlink" href="#Loading-the-Images" title="Permalink to this heading">¶</a></h2>
<p>Now we will import the style and content images. The original PIL images have values between 0 and 255, but when transformed into torch tensors, their values are converted to be between 0 and 1. The images also need to be resized to have the same dimensions. An important detail to note is that neural networks from the torch library are trained with tensor values ranging from 0 to 1. If you try to feed the networks with 0 to 255 tensor images, then the activated feature maps will be unable to
sense the intended content and style. However, pre-trained networks from the Caffe library are trained with 0 to 255 tensor images.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># desired size of the output image
imsize = 512 if torch.cuda.is_available() else 128  # use small size if no gpu

loader = transforms.Compose([
    transforms.Resize(imsize),  # scale imported image
    transforms.ToTensor()])  # transform it into a torch tensor


def image_loader(image_name):
    image = Image.open(image_name)
    # fake batch dimension required to fit network&#39;s input dimensions
    image = loader(image).unsqueeze(0)
    return image.to(device, torch.float)


style_img = image_loader(&quot;images/style_img.jpg&quot;)
content_img = image_loader(&quot;images/content_img.jpg&quot;)

try:
    assert style_img.size() == content_img.size()
except:
    print(&quot;we need to import style and content images of the same size&quot;)
    print(f&quot;Style Image size: {style_img.size()}&quot;)
    print(f&quot;Content Image size: {content_img.size()}&quot;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
we need to import style and content images of the same size
Style Image size: torch.Size([1, 3, 157, 128])
Content Image size: torch.Size([1, 3, 170, 128])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>style_img = fn.resize(style_img, size=[170, 128])
style_img.size()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
torch.Size([1, 3, 170, 128])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>content_img.size()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
torch.Size([1, 3, 170, 128])
</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>assert style_img.size() == content_img.size(), \
    &quot;we need to import style and content images of the same size&quot;
</pre></div>
</div>
</div>
<p>Now, let’s create a function that displays an image by reconverting a copy of it to PIL format and displaying the copy using <code class="docutils literal notranslate"><span class="pre">plt.imshow</span></code>. We will try displaying the content and style images to ensure they were imported correctly.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>unloader = transforms.ToPILImage()  # reconvert into PIL image

plt.ion()

def imshow(tensor, title=None):
    image = tensor.cpu().clone()  # we clone the tensor to not do changes on it
    image = image.squeeze(0)      # remove the fake batch dimension
    image = unloader(image)
    fig, ax = plt.subplots()
    plt.imshow(image)
    if title is not None:
        plt.title(title)
    plt.pause(0.001) # pause a bit so that plots are updated

    return image


# plt.figure()
_ = imshow(style_img, title=&#39;Style Image&#39;)

# plt.figure()
_ = imshow(content_img, title=&#39;Content Image&#39;)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/neural_style_11_0.png" src="_images/neural_style_11_0.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/neural_style_11_1.png" src="_images/neural_style_11_1.png" />
</div>
</div>
</section>
<section id="Loss-Functions">
<h2>Loss Functions<a class="headerlink" href="#Loss-Functions" title="Permalink to this heading">¶</a></h2>
<p>Content Loss ~~~~~~~~~~~~</p>
<p>The content loss is a function that represents a weighted version of the content distance for an individual layer. The function takes the feature maps <span class="math notranslate nohighlight">\(F_{XL}\)</span> of a layer <span class="math notranslate nohighlight">\(L\)</span> in a network processing input <span class="math notranslate nohighlight">\(X\)</span> and returns the weighted content distance <span class="math notranslate nohighlight">\(w_{CL}.D_C^L(X,C)\)</span> between the image <span class="math notranslate nohighlight">\(X\)</span> and the content image <span class="math notranslate nohighlight">\(C\)</span>. The feature maps of the content image(<span class="math notranslate nohighlight">\(F_{CL}\)</span>) must be known by the function in order to calculate the content distance. We implement
this function as a torch module with a constructor that takes <span class="math notranslate nohighlight">\(F_{CL}\)</span> as an input. The distance <span class="math notranslate nohighlight">\(\|F_{XL} - F_{CL}\|^2\)</span> is the mean square error between the two sets of feature maps, and can be computed using <code class="docutils literal notranslate"><span class="pre">nn.MSELoss</span></code>.</p>
<p>We will add this content loss module directly after the convolution layer(s) that are being used to compute the content distance. This way each time the network is fed an input image the content losses will be computed at the desired layers and because of auto grad, all the gradients will be computed. Now, in order to make the content loss layer transparent we must define a <code class="docutils literal notranslate"><span class="pre">forward</span></code> method that computes the content loss and then returns the layer’s input. The computed loss is saved as a
parameter of the module.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class ContentLoss(nn.Module):

    def __init__(self, target,):
        super(ContentLoss, self).__init__()
        # we &#39;detach&#39; the target content from the tree used
        # to dynamically compute the gradient: this is a stated value,
        # not a variable. Otherwise the forward method of the criterion
        # will throw an error.
        self.target = target.detach()

    def forward(self, input):
        self.loss = F.mse_loss(input, self.target)
        return input
</pre></div>
</div>
</div>
<p>Style Loss ~~~~~~~~~~</p>
<p>The style loss module is implemented similarly to the content loss module. It will act as a transparent layer in a network that computes the style loss of that layer. In order to calculate the style loss, we need to compute the gram matrix <span class="math notranslate nohighlight">\(G_{XL}\)</span>. A gram matrix is the result of multiplying a given matrix by its transposed matrix. In this application the given matrix is a reshaped version of the feature maps <span class="math notranslate nohighlight">\(F_{XL}\)</span> of a layer <span class="math notranslate nohighlight">\(L\)</span>. <span class="math notranslate nohighlight">\(F_{XL}\)</span> is reshaped to form
<span class="math notranslate nohighlight">\(\hat{F}_{XL}\)</span>, a <span class="math notranslate nohighlight">\(K\)</span> x <span class="math notranslate nohighlight">\(N\)</span> matrix, where <span class="math notranslate nohighlight">\(K\)</span> is the number of feature maps at layer <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(N\)</span> is the length of any vectorized feature map <span class="math notranslate nohighlight">\(F_{XL}^k\)</span>. For example, the first line of <span class="math notranslate nohighlight">\(\hat{F}_{XL}\)</span> corresponds to the first vectorized feature map <span class="math notranslate nohighlight">\(F_{XL}^1\)</span>.</p>
<p>Finally, the gram matrix must be normalized by dividing each element by the total number of elements in the matrix. This normalization is to counteract the fact that <span class="math notranslate nohighlight">\(\hat{F}_{XL}\)</span> matrices with a large <span class="math notranslate nohighlight">\(N\)</span> dimension yield larger values in the Gram matrix. These larger values will cause the first layers (before pooling layers) to have a larger impact during the gradient descent. Style features tend to be in the deeper layers of the network so this normalization step is crucial.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def gram_matrix(input):
    a, b, c, d = input.size()  # a=batch size(=1)
    # b=number of feature maps
    # (c,d)=dimensions of a f. map (N=c*d)

    features = input.view(a * b, c * d)  # resise F_XL into \hat F_XL

    G = torch.mm(features, features.t())  # compute the gram product

    # we &#39;normalize&#39; the values of the gram matrix
    # by dividing by the number of element in each feature maps.
    return G.div(a * b * c * d)
</pre></div>
</div>
</div>
<p>Now the style loss module looks almost exactly like the content loss module. The style distance is also computed using the mean square error between <span class="math notranslate nohighlight">\(G_{XL}\)</span> and <span class="math notranslate nohighlight">\(G_{SL}\)</span>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class StyleLoss(nn.Module):

    def __init__(self, target_feature):
        super(StyleLoss, self).__init__()
        self.target = gram_matrix(target_feature).detach()

    def forward(self, input):
        G = gram_matrix(input)
        self.loss = F.mse_loss(G, self.target)
        return input
</pre></div>
</div>
</div>
</section>
<section id="Importing-the-Model">
<h2>Importing the Model<a class="headerlink" href="#Importing-the-Model" title="Permalink to this heading">¶</a></h2>
<p>Now we need to import a pre-trained neural network. We will use a 19 layer VGG network like the one used in the paper.</p>
<p>PyTorch’s implementation of VGG is a module divided into two child <code class="docutils literal notranslate"><span class="pre">Sequential</span></code> modules: <code class="docutils literal notranslate"><span class="pre">features</span></code> (containing convolution and pooling layers), and <code class="docutils literal notranslate"><span class="pre">classifier</span></code> (containing fully connected layers). We will use the <code class="docutils literal notranslate"><span class="pre">features</span></code> module because we need the output of the individual convolution layers to measure content and style loss. Some layers have different behavior during training than evaluation, so we must set the network to evaluation mode using <code class="docutils literal notranslate"><span class="pre">.eval()</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>cnn = models.vgg19(pretrained=True).features.to(device).eval()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
/Users/james/miniconda3/envs/ds_env/lib/python3.9/site-packages/torchvision/models/_utils.py:208: UserWarning: The parameter &#39;pretrained&#39; is deprecated since 0.13 and will be removed in 0.15, please use &#39;weights&#39; instead.
  warnings.warn(
/Users/james/miniconda3/envs/ds_env/lib/python3.9/site-packages/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for &#39;weights&#39; are deprecated since 0.13 and will be removed in 0.15. The current behavior is equivalent to passing `weights=VGG19_Weights.IMAGENET1K_V1`. You can also use `weights=VGG19_Weights.DEFAULT` to get the most up-to-date weights.
  warnings.warn(msg)
</pre></div></div>
</div>
<p>Additionally, VGG networks are trained on images with each channel normalized by mean=[0.485, 0.456, 0.406] and std=[0.229, 0.224, 0.225]. We will use them to normalize the image before sending it into the network.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>cnn_normalization_mean = torch.tensor([0.485, 0.456, 0.406]).to(device)
cnn_normalization_std = torch.tensor([0.229, 0.224, 0.225]).to(device)

# create a module to normalize input image so we can easily put it in a
# nn.Sequential
class Normalization(nn.Module):
    def __init__(self, mean, std):
        super(Normalization, self).__init__()
        # .view the mean and std to make them [C x 1 x 1] so that they can
        # directly work with image Tensor of shape [B x C x H x W].
        # B is batch size. C is number of channels. H is height and W is width.
        self.mean = torch.tensor(mean).view(-1, 1, 1)
        self.std = torch.tensor(std).view(-1, 1, 1)

    def forward(self, img):
        # normalize img
        return (img - self.mean) / self.std
</pre></div>
</div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">Sequential</span></code> module contains an ordered list of child modules. For instance, <code class="docutils literal notranslate"><span class="pre">vgg19.features</span></code> contains a sequence (Conv2d, ReLU, MaxPool2d, Conv2d, ReLU…) aligned in the right order of depth. We need to add our content loss and style loss layers immediately after the convolution layer they are detecting. To do this we must create a new <code class="docutils literal notranslate"><span class="pre">Sequential</span></code> module that has content loss and style loss modules correctly inserted.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># desired depth layers to compute style/content losses :
content_layers_default = [&#39;conv_4&#39;]
style_layers_default = [&#39;conv_1&#39;, &#39;conv_2&#39;,
                        &#39;conv_3&#39;, &#39;conv_4&#39;,
                        &#39;conv_5&#39;, &#39;conv_6&#39;,
                        &#39;conv_7&#39;, &#39;conv_8&#39;,
                        &#39;conv_9&#39;, &#39;conv_10&#39;]

def get_style_model_and_losses(cnn,
                                normalization_mean,
                                normalization_std,
                               style_img,
                               content_img,
                               content_layers=content_layers_default,
                               style_layers=style_layers_default):
    # normalization module
    normalization = Normalization(normalization_mean, normalization_std).to(device)

    # just in order to have an iterable access to or list of content/syle
    # losses
    content_losses = []
    style_losses = []

    # assuming that cnn is a nn.Sequential, so we make a new nn.Sequential
    # to put in modules that are supposed to be activated sequentially
    model = nn.Sequential(normalization)

    i = 0  # increment every time we see a conv
    for layer in cnn.children():
        if isinstance(layer, nn.Conv2d):
            i += 1
            name = &#39;conv_{}&#39;.format(i)
        elif isinstance(layer, nn.ReLU):
            name = &#39;relu_{}&#39;.format(i)
            # The in-place version doesn&#39;t play very nicely with the ContentLoss
            # and StyleLoss we insert below. So we replace with out-of-place
            # ones here.
            layer = nn.ReLU(inplace=False)
        elif isinstance(layer, nn.MaxPool2d):
            name = &#39;pool_{}&#39;.format(i)
        elif isinstance(layer, nn.BatchNorm2d):
            name = &#39;bn_{}&#39;.format(i)
        else:
            raise RuntimeError(&#39;Unrecognized layer: {}&#39;.format(layer.__class__.__name__))

        model.add_module(name, layer)

        if name in content_layers:
            # add content loss:
            target = model(content_img).detach()
            content_loss = ContentLoss(target)
            model.add_module(&quot;content_loss_{}&quot;.format(i), content_loss)
            content_losses.append(content_loss)

        if name in style_layers:
            # add style loss:
            target_feature = model(style_img).detach()
            style_loss = StyleLoss(target_feature)
            model.add_module(&quot;style_loss_{}&quot;.format(i), style_loss)
            style_losses.append(style_loss)

    # now we trim off the layers after the last content and style losses
    for i in range(len(model) - 1, -1, -1):
        if isinstance(model[i], ContentLoss) or isinstance(model[i], StyleLoss):
            break

    model = model[:(i + 1)]

    return model, style_losses, content_losses
</pre></div>
</div>
</div>
<p>Next, we select the input image. You can use a copy of the content image or white noise.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>input_img = content_img.clone()
# if you want to use white noise instead uncomment the below line:
# input_img = torch.randn(content_img.data.size(), device=device)

# add the original input image to the figure:
_ = imshow(input_img, title=&#39;Input Image&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/neural_style_25_0.png" src="_images/neural_style_25_0.png" />
</div>
</div>
</section>
<section id="Gradient-Descent">
<h2>Gradient Descent<a class="headerlink" href="#Gradient-Descent" title="Permalink to this heading">¶</a></h2>
<p>As Leon Gatys, the author of the algorithm, suggested <code class="docutils literal notranslate"><span class="pre">here</span> <span class="pre">&lt;https://discuss.pytorch.org/t/pytorch-tutorial-for-neural-transfert-of-artistic-style/336/20?u=alexis-jacq&gt;</span></code>__, we will use L-BFGS algorithm to run our gradient descent. Unlike training a network, we want to train the input image in order to minimise the content/style losses. We will create a PyTorch L-BFGS optimizer <code class="docutils literal notranslate"><span class="pre">optim.LBFGS</span></code> and pass our image to it as the tensor to optimize.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def get_input_optimizer(input_img):
    # this line to show that input is a parameter that requires a gradient
    optimizer = optim.LBFGS([input_img])
    return optimizer
</pre></div>
</div>
</div>
<p>Finally, we must define a function that performs the neural transfer. For each iteration of the networks, it is fed an updated input and computes new losses. We will run the <code class="docutils literal notranslate"><span class="pre">backward</span></code> methods of each loss module to dynamicaly compute their gradients. The optimizer requires a “closure” function, which reevaluates the module and returns the loss.</p>
<p>We still have one final constraint to address. The network may try to optimize the input with values that exceed the 0 to 1 tensor range for the image. We can address this by correcting the input values to be between 0 to 1 each time the network is run.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def run_style_transfer(cnn,
                        normalization_mean,
                        normalization_std,
                       content_img,
                       style_img,
                       input_img,
                       num_steps=1000,
                       style_weight=1000000, content_weight=1):
    &quot;&quot;&quot;Run the style transfer.&quot;&quot;&quot;
    print(&#39;Building the style transfer model..&#39;)
    model, style_losses, content_losses = get_style_model_and_losses(cnn,
        normalization_mean, normalization_std, style_img, content_img)

    # We want to optimize the input and not the model parameters so we
    # update all the requires_grad fields accordingly
    input_img.requires_grad_(True)
    model.requires_grad_(False)

    optimizer = get_input_optimizer(input_img)

    print(&#39;Optimizing..&#39;)
    run = [0]
    while run[0] &lt;= num_steps:

        def closure():
            # correct the values of updated input image
            with torch.no_grad():
                input_img.clamp_(0, 1)

            optimizer.zero_grad()
            model(input_img)
            style_score = 0
            content_score = 0

            for sl in style_losses:
                style_score += sl.loss
            for cl in content_losses:
                content_score += cl.loss

            style_score *= style_weight
            content_score *= content_weight

            loss = style_score + content_score
            loss.backward()

            run[0] += 1
            if run[0] % 100 == 0:
                print(&quot;run {}:&quot;.format(run))
                print(&#39;Style Loss : {:4f} Content Loss: {:4f}&#39;.format(
                    style_score.item(), content_score.item()))
                print()

            return style_score + content_score

        optimizer.step(closure)

    # a last correction...
    with torch.no_grad():
        input_img.clamp_(0, 1)

    return input_img
</pre></div>
</div>
</div>
<p>Finally, we can run the algorithm.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>output = run_style_transfer(cnn,
                            cnn_normalization_mean,
                            cnn_normalization_std,
                            content_img,
                            style_img,
                            input_img,
                            num_steps=500,
                            style_weight=1000000 #1000000
                            )

# plt.figure()
# imshow(output, title=&#39;Output Image&#39;)

# # sphinx_gallery_thumbnail_number = 4
# plt.ioff()
# plt.show()
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Building the style transfer model..
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
/var/folders/76/w4hjx50937lb151qm8l0xq_w0000gn/T/ipykernel_73027/1744401072.py:12: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.mean = torch.tensor(mean).view(-1, 1, 1)
/var/folders/76/w4hjx50937lb151qm8l0xq_w0000gn/T/ipykernel_73027/1744401072.py:13: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.std = torch.tensor(std).view(-1, 1, 1)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Optimizing..
run [100]:
Style Loss : 474.479095 Content Loss: 62.232918

run [200]:
Style Loss : 378.271027 Content Loss: 65.982285

run [300]:
Style Loss : 306.477478 Content Loss: 67.984390

run [400]:
Style Loss : 258.166260 Content Loss: 69.344818

run [500]:
Style Loss : 240.144394 Content Loss: 70.163918

</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>mixed = imshow(output, title=&#39;Output Image&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/neural_style_32_0.png" src="_images/neural_style_32_0.png" />
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>mixed.resize((600, 800)).save(&quot;images/mixed_img.png&quot;, quality=400)
</pre></div>
</div>
</div>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/neural_style.nblink.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2022, James Twose.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>